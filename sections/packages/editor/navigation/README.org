* Navigation Helpers
These packages improve navigation within the editor and its parts.

** Dired Plus
Extends upon bundled [[https://github.com/emacs-mirror/emacs/blob/master/lisp/dired.el][dired.el]] and adds more functionality.
#+BEGIN_SRC emacs-lisp
  (let
      (;; local variable declarations
          (_init (lambda ()
              ;; Setup the key which will allow us to trigger dired mode
              (add-hook 'evil-leader-mode-hook '(lambda ()
                  (evil-leader/set-key "." 'dired-jump)
              ))
          ))
          (_conf (lambda ()
              ;; Improve default dired functionality
              (use-package dired-x :demand t)
              ;; When evil mode is available cerate a new key-map specially for dired-mode
              (add-hook 'evil-local-mode-hook '(lambda ()
                  (evil-make-overriding-map dired-mode-map 'normal t); the standard bindings
                  (evil-define-key 'normal dired-mode-map
                      "gg" 'evil-goto-first-line
                      "G" 'evil-goto-line
                      "h" 'evil-backward-char
                      "j" 'evil-next-line
                      "k" 'evil-previous-line
                      "l" 'evil-forward-char
                      "w" 'evil-forward-word-begin
                      "b" 'evil-backward-word-begin
                      "e" 'evil-forward-WORD-end
                  )
              ))
              ;; Reuse the dired buffer when moving between directories
              (diredp-toggle-find-file-reuse-dir 1)
          ))
      )
      ;; once dired is available, load the package.
      ;; Since dired+ is no longer available on melpa, use quelpa,
      ;; but avoid checking for updates on every load.
      (if (package-installed-p 'dired+)
          (use-package dired+
              :after dired
              :init (funcall _init)
              :config (funcall _conf)
          )
          (use-package dired+
              :after dired
              :quelpa (dired+ :fetcher github :repo "emacsmirror/dired-plus")
              :init (funcall _init)
              :config (funcall _conf)
          )
      )
  )
#+END_SRC

** Helm
The CtrlP of Emacs, only waaaay better.
#+BEGIN_SRC emacs-lisp
  (use-package helm
      :ensure t
      :commands helm-mode
      :delight helm-mode
      :init
          (add-hook 'after-init-hook (lambda ()
              (ido-mode -1); Disable the "I Do" mode, we have helm for that now.
              (helm-mode 1)
          ))
          (add-hook 'evil-leader-mode-hook (lambda ()
              (evil-leader/set-key "DEL" 'helm-mini)
              (evil-leader/set-key "SPC" 'helm-M-x)
          ))
      :config
          ;; Cannot use the ':bind' macro because helm-config would just override it
          ;; so, let's unbind and bind by hand.
          (require 'helm-config); load defaults
          ;; TODO: need to do further testing to figure out what "imenu" does.
          (define-key global-map (kbd "C-x c I") nil); original key-binding
          (define-key global-map (kbd "M-d") 'helm-imenu-in-all-buffers)
          ;; replace Emacs help with helm-apropos
          (define-key global-map (kbd "C-h C-h") nil); The emacs help for help
          (define-key global-map (kbd "C-x c a") nil); The original helm-apropos binding
          (define-key global-map (kbd "C-h C-h") 'helm-apropos)
          ;; Map the dynamic kill-ring
          (define-key global-map (kbd "C-x c M-y") nil); The original helm-show-kill-ring
          (define-key global-map (kbd "M-v") 'helm-show-kill-ring); The scroll-down-command
          ;; Further customization
          (setq
              helm-candidate-number-limit 100
              helm-mode-fuzzy-match t
              helm-completion-in-region-fuzzy-match t
              helm-autoresize-mode t
              helm-buffer-max-length 50
              helm-follow-mode-persistent t
              ;; Try to update faster when hitting RET too quickly
              helm-idle-delay 0.0
              helm-input-idle-delay 0.0
              helm-yas-display-key-on-candidate t
              helm-quick-update t
              helm-M-x-requires-pattern nil
              helm-ff-skip-boring-files t
          )
  )
#+END_SRC

** Projectile
Write a description here
#+BEGIN_SRC emacs-lisp
  (use-package projectile
      :ensure t
      :delight projectile-mode
      :commands projectile-mode
      :init (add-hook 'helm-mode-hook #'projectile-mode)
      :config
          ;; If the projectile folder doesn't exist, create it.
          ;;(unless (file-exists-p etor/projectile-dir) (make-directory etor/projectile-dir));
          (setq
              ;; TODO: find out more about this action.
              projectile-switch-project-action 'projectile-find-file
              ;; use external tools for indexing for speed
              projectile-indexing-method 'alien
              ;; Setup custom filenames for autosaving.
              ;; projectile-cache-file
              ;;     (expand-file-name "cache" etor/projectile-dir)
              ;; projectile-known-projects-file
              ;;     (expand-file-name "known_projects" etor/projectile-dir)
              ;; ignore these folders when trying to add as project
              ;; TODO: Throws an error
              ;; projectile-ignored-project-function (lambda (project-root)
              ;;     (f-descendant-of? project-root (expand-file-name ".git"))
              ;; )
              ;; Determine how to locate the root folder for the project
              projectile-project-root-files-functions '(
                  projectile-root-local
                  projectile-root-top-down
                  projectile-root-bottom-up
              )
          )
          ;; Everytime the project is changed, remove/restore projects
          ;; (add-hook 'projectile-before-switch-project-hook 'etor/projectile-buffers-save-and-kill)
          ;; (add-hook 'projectile-after-switch-project-hook 'etor/projectile-buffers-load)
  )
#+END_SRC

** Projectile & Helm Integration
This connects boths modes so they work together.
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
      :ensure t
      :after (helm projectile)
      :config
          ;; Enable helm-projectile
          (define-key global-map [(meta f)] 'helm-projectile-find-file); forward-word
          ;; Enable finding directories
          (define-key global-map [(meta shift f)] 'helm-projectile-find-dir)
          ;; Enable finding buffers
          (define-key global-map (kbd "M-b") 'helm-projectile-switch-to-buffer); orig: backward-char
          ;; Enable finding projects
          (define-key global-map (kbd "M-p") 'helm-projectile-switch-project);
          ;; replace Ctrl-F with Helm file search
          (eval-after-load 'evil-maps (lambda ()
              (define-key evil-normal-state-map (kbd "C-f") nil)
              (define-key evil-emacs-state-map (kbd "C-f") nil)
              (define-key evil-motion-state-map (kbd "C-f") nil)
              (define-key evil-operator-state-map (kbd "C-f") nil)
              (define-key evil-visual-state-map (kbd "C-f") nil)
              (define-key evil-replace-state-map (kbd "C-f") nil)
              (define-key global-map [(ctrl f)] nil)
              (define-key global-map [(ctrl shift f)] nil)
              (define-key global-map [(ctrl f)] 'helm-do-ag)
              (define-key global-map [(ctrl shift f)] 'projectile-replace-regexp)
          ))

      )
#+END_SRC

# ;; (require 'elpa-neotree)
# ;; (require 'elpa-origami)
# ;; (require 'elpa-ace-window)
