#+TITLE: Declarations

** [[./declarations-path.org][Path managemement]]
   Functions that allow to centralise path management througout the config.
   #+INCLUDE: ./declarations-path.org

** [[./declarations-frame.org][Frame State]]
   Functions that allow to manage state for frame position and shape.
   #+INCLUDE: ./declarations-frame.org

#+BEGIN_SRC emacs-lisp
  ;; ------------------------------------------------------------------ Minimal Vars & Funcs
  ;; These are the minimal custom variables and functions needed to startup the config.
  (defvar etor/init:flag "_DELME-TO-UPDATE.flag")

#+END_SRC

** window-toggle
Toggle current buffer using the whole screen.
#+BEGIN_SRC emacs-lisp
  (defun etor/window-toggle ()
      "Allows to maximize current buffer"
      (interactive)
      (if (= 1 (length (window-list)))
          (jump-to-register '_)
          (progn
              (window-configuration-to-register '_)
              (delete-other-windows)
          )
      )
  )
#+END_SRC

#+BEGIN_SRC emacs-lisp

(defun etor/backspace-to-tab-stop ()
    "Delete whitespace backwards to the next tab-stop, otherwise delete one character."
    (interactive)
    (if
        (or indent-tabs-mode
            (region-active-p)
            (save-excursion
                (> (point) (progn (back-to-indentation) (point)))
            ))
        (call-interactively 'backward-delete-char-untabify)
        (let
            ((movement (% (current-column) tab-width)) (p (point)))
            (when (= movement 0) (setq movement tab-width))
            ;; Account for edge case near beginning of buffer
            (setq movement (min (- p 1) movement))
            (save-match-data
                (if
                    (string-match "[^\t ]*\\([\t ]+\\)$"
                        (buffer-substring-no-properties (- p movement) p)
                    )
                    (backward-delete-char (- (match-end 1) (match-beginning 1)))
                    (call-interactively 'backward-delete-char)
                )
            )
        )
    )
)   )

#+END_SRC

#+BEGIN_SRC emacs-lisp
(defvar etor/projectile-dir
        (expand-file-name "_projectile/" user-emacs-directory)
    )
(defun etor/projectile-buffers-get-filename ()
    "Retrieve the location for the sevefile."
    (expand-file-name
        (replace-regexp-in-string "/" "#" (projectile-project-root))
        etor/projectile-dir
    )
)

#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun etor/projectile-buffers-save-and-kill ()
    "Save currently open buffers to a file."
    (interactive)
    (let
        (
            (_savefile (etor/projectile-buffers-get-filename))
            (_filenames (list (buffer-file-name (current-buffer))))
        )
        (dolist (buffer (buffer-list))
            (let
                (
                    (_path (buffer-file-name buffer))
                    (_name (buffer-name buffer))
                )
                (when (and (not (string-match-p "^\\\s*\\*" _name)) _path)
                    (add-to-list '_filenames _path)
                )
            )
        )
        (if (file-writable-p _savefile)
            (with-temp-file _savefile
                (insert (let (print-length) (prin1-to-string _filenames)))
                (write-file _savefile)
            )
            (error "Could not write to projectile savefile")
        )
        (desktop-clear)
        (print (concat "Saved " (number-to-string (length _filenames)) " buffers."))
    )
)
#+END_SRC


#+BEGIN_SRC emacs-lisp
(defun etor/projectile-buffers-load ()
    "Load previously open buffers from a file."
    (interactive)
    (let
        (
            (_currname (buffer-file-name (current-buffer)))
            (_filename (etor/projectile-buffers-get-filename))
        )
        (when (file-exists-p _filename)
            (with-temp-buffer (insert-file-contents _filename)
                (dolist (_path (read (buffer-string)))
                    (when (file-exists-p _path) (find-file _path))
                )
                (find-file _currname)
            )
        )
    )
)
#+END_SRC
